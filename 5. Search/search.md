## DFS 深度优先搜索

（1）有n件物品，每件物品的重量为w[i]，价值为c[i]。现在需要选出若干件物品放入一个容量为V的背包中，使得在选入背包的物品重量和不超过容量V的前提下，让背包中物品的价值之和最大，求最大价值（1<=n<=20）

- 对每件物品都有选或者不选两种选择，这就是所谓的岔道口，当选择的物品总和超过v就会到达死胡同，需要返回最近的岔路口。- 因为每次都要对物品进行选择，所以DFS参数必须记录当前处理的物品编号index，处理当前物品之前，已选物品的总重量sumW与总价值sumC
- 一旦index增长到了n，说明n件物品处理完毕，此时记录的sumW与sumV就是所选物品的总重量和总价值。代码如下
    ```c
    void DFS(int index, int sumW, int sumC){
        if(index == n){
            if(sumW <= V && sumC > maxValue){
                maxValue = sumC;
            }
            return;
        }
        DFS(index + 1, sumW, sumC);
        DFS(index + 1, sumW + w[index], sumC + c[index])
    }
    ```
- 由于每件物品由两种选择，所以上面代码复杂度为$2^n$，我们可以通过剪枝操作来降低计算量，上面我们总是把n件物品的选择全部确定之后才去更新其最大值，事实上忽略了背包容量不超过V这个特点，因此可以把sumW的判断加入岔路口中，只有sumW<=V时才进去入道。


（2）给定N个整数(可能有负数)，从中选择K个数，使得这K个数之和恰好等于一个给定的整数X；如果有多种方案，选择它们中元素平方和最大的一个。数据保证这样的方案唯一。

- 需要记录当前处理的整数编号index，当前已经选择的数的个数nowK，当前已选整数之和与平方和sum和sumSqu。
- 如何保存平方和最大的方案：数组temp存放当前选择的整数 ，当试图进入“选index号数”这个分支时，把A[index]加入temp中，当这条分支结束时，就把它从temp数组中去除，使他不会影响“不选index号数”这个分支。接着如果在某个时候发现已经选择了K个数且它们和恰好为x时，判断平方和大小并更新。


## BFS 广度优先搜索
以广度为第一关键词，当碰到岔道口时，总是先依次访问从该岔道口能直接到达的所有结点，再按这些结点被访问的顺序去依次访问它们能直接到达的所有结点，以此类推，直到所有节点都被访问为止。

```c
void BFS(int s){
    queue<int> q;
    q.push(s);
    while(!q.empty()){
        取出队首元素top;
        访问队首元素top;
        将队首元素出队;
        将top结的下一未层点中曾入结的队点全部入队，并设置成已入队;
    }
}
```
给出一个m*n的矩阵，矩阵中的元素为0或1。称位置(x,y)与其上下左右四个位置(x,y+1)、(x,y-1)、(x-1,y)、(x+1,y)是相邻的。如果矩阵中有若干个1是相邻的(不必两两相邻)，那么称这些1构成了一个“块”。求给定的矩阵中“块”的个数。

枚举每一个位置的元素，如果为0则跳过，如果为1，则使用BFS查询与该位置相邻的四个位置（前提是不出界），判断它们是否为1，如果某个相邻的位置为1，则同样去查询与该位置相邻的四个位置，直到整个“1”块访问完毕。为了防止走回头路，设置一个bool型数组inq来记录每个位置是否已经在BFS中入过队。

**注意**
1. BFS中设置的inq数组的含义是判断结点**是否已经入过队**，而不是结点是否已被访问。区别在于如果设置成是都已经访问，有可能某个结点正在队列中(但还未访问)时由于其他结点可以到达它而将这个结点再次入队，导致很多结点反复入队。
2. 当使用STL的queue时，元素入队的push操作只是制造了该元素的一个副本入队，因此在入队后对原元素的修改不会影响队列中的副本，而对队列中副本的改变也不会改变原元素。

