## 二叉树的遍历
1. 1020 Tree Traversals

    给出一棵二叉树的后序遍历序列和中序遍历序列，求这棵二叉树的层序遍历序列

2. 1086 Tree Traversals Again 

    用栈模拟一棵二叉树的先序和中序遍历过程，求这棵二叉树的后序遍历序列

## 二叉树的静态实现

3. 1102 Invert a Binary Tree

    二叉树有N个结点，给出每个结点的左右孩子结点的编号，把该二叉树反转（即把每个结点的左右子树都交换），输出反转后二叉树的层序遍历序列和中序遍历序列。

## 树的遍历

4. 1090 Highest Price in Supply Chain

    给出一棵销售供应的树，树根唯一。在树根处货物的价格为P，然后从根结点开始每往子结点走一层，该层的货物价格将会在父亲结点的价格上增加r%。求所有叶结点中的最高价格以及这个价格的叶结点数

5. 1079 Total Sales of Supply Chain

    给出一棵销售供应的树，树根唯一。在树根处货物的价格为P，然后从根结点开始每往子结点走一层，该层的货物价格将会在父亲结点的价格上增加r%。给出每个叶结点的货物量，求它们的价格之和

6. 1106 Lowest Price in Supply Chain

    给出一棵销售供应的树，树根唯一。在树根处货物的价格为P，然后从根结点开始每往子结点走一层，该层的货物价格将会在父亲结点的价格上增加r%。求叶子结点处能获得的最低价格以及能提供最低价格的叶子结点的个数

7. 1094 The Largest Generation

    输入树的结点个数N（编号为1~N）、非叶结点个数M，然后输入M个非叶子结点各自的孩子结点编号，求结点个数最多的一层（根结点层号为1），输出该层的结点个数以及层号

8. 1004 Counting Leaves

    给出一棵树，问每层各有多少叶子结点

9. 1053 Path of Equal Weight（***）

    给定一棵树和每个结点的权值，求所有从根结点到叶子结点的路径，使得每条路径上结点的权值之和等于给定的常数S，如果有多条路径，按路径非递增的顺序输出（关键在于递归的时候记录路径）



## 二叉查找树
10. 1043 Is It a Binary Search Tree 

    给出N个正整数来作为一棵二叉排序树的结点插入顺序，问这串序列是否是该二叉排序树的先序序列或是该二叉排序树的先序序列，如果是，输出对应的树的后序遍历

11. 1064 Complete Binary Search Tree（**）

    给出N个非负整数，要用它们构建出一棵完全二叉排序树，输出这棵完全二叉排序树的层序遍历序列

12. 1099 Build A Binary Search Tree 

    二叉树有N个结点（结点编号0~N-1），给出每个结点的左右孩子结点的编号（不存在用-1表示）。接着给出一个N个整数的序列，需要把这N个整数填入二叉树的结点中，使得二叉树成为一个二叉查找树，输出这棵二叉查找树的层序遍历序列。



## 平衡二叉树
13. 1066 Root of AVL Tree

    给出N个正整数，将它们依次插入一棵初始为空的AVL树上，求插入后根结点的值

## 并查集 
14. 1107 Social Clusters（**）

    N个人，每个人喜欢若干项运动，如果两个人有任意一个运动相同，就称他们处于同一个社交网络。求这N个人总共形成了多少个社交网络

## 堆
15. 1098 Insertion or Heap Sort

    给出一个初始序列，可以对它使用插入排序或堆排序法进行排序。现在给出一个序列，判断它是由插入排序还是堆排序产生的，并输出下一步将会产生的序列

## 二叉树的遍历
16. 1110 Complete Binary Tree

    给定一棵二叉树，判断其是否为完全二叉树。如果是的话，同时输出该二叉树最后一个结点编号，否则输出根结点编号

17. 1119 Pre- and Post-order Traversals（***）

    给出两个序列作为二叉树的先序序列和后序序列，序列呢i数字各不相同，判断是是否能唯一确定一棵二叉树，输出任意一棵符合的二叉树的中序序列


## 平衡二叉树

18. 1123 Is It a Complete AVL Tree

    给出N个不同的正整数作为AVL树的插入顺序，判断生成的AVL树是否是完全二叉树，并输出对应的层序序列（A1066和A1110的结合题）












