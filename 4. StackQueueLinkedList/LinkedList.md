## 链表
链表的结点由两部分组成，数据域和指针域。指针域指向下一个结点的地址
```c
struct Node{
    typename data;//数据域
    Node* next;//指针域
}
```


### 给链表节点分配内存空间

1. malloc函数：`stdlib.h`头文件下用于申请动态内存的函数，返回类型是申请的同类型变量的指针。
    ```c
    typename* p = (typename*)malloc(sizeof(typename));
    ```
    以需要申请的内存空间大小（即sizeof(Node)）为malloc函数的参数，malloc函数会向内存申请一块大小为sizeof(Node)的空间，并返回指向这段空间的指针，类型为void*，需要将它强制转换为Node*型。如果访问失败，会返回空指针。失败一般发生在使用malloc申请了较大的动态数组，如
    ```c
    int* p = (int*)malloc(1000000 * sizeof(int));
    ```
2. new运算符，返回申请的同变量类型的指针
    ```c
    typename* p = new typename;
    ```
    如果申请失败，则会启动C++异常机制处理而不是返回空指针NULL。
3. 内存泄漏，指使用malloc与new开辟出来的内存空间再使用后没有释放，导致其在程序结束之前始终占据该内存空间，在一些较大的程序中容易导致内存消耗过快以至最后无内存分配。
    1. `free(p)`对应malloc函数，先释放指针变量p所指向的内存空间，然后将指针变量p指向空地址NULL。在free函数执行后，指针变量p本身并没有消失。
    2. `delete(p)`对应new运算符

### 静态链表 
如果结点的地址是比较小的整数（例如5位数的地址，在题目中给出），这样可以使用用静态链表，原理是hash，即通过建立一个结构体数组，并令数组的下标直接表示系欸但的地址，来达到直接访问数组中的元素就能访问结点的效果。静态链表不需要头结点。
```c
struct Node{
    typename data;//数据域
    int next;//指针域，存放下一个结点的数组下标
}node[maxn];
```

## 用栈来实现简单计算器

读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。测试输入包含多个测试用例，每个测试用例占一行，没有非法表达式和括号，当一行中只有0时输入结束，相应的结果不要输出。

计算表达式都是中缀表达式，我们需要先把它转成后缀表达式，然后计算后缀表达式

**步骤1：中缀表达式转后缀表达式**

1. 设立一个操作符栈，用以临时存放操作符；设立一个数组或者队列，用以存放后缀表达式
2. 从左至右扫描中缀表达式，如果碰到操作数（注意：操作数可能不止一位，因此需要一位一位读入然后合并在一起），就把操作数加入后缀表达式中
3. 如果碰到操作符op，就将其优先级与操作符栈的栈顶操作符的优先级比较
   1. 若op的优先级高于栈顶操作符优先级，则压入操作符栈
   2. 若op的优先级低于或等于栈顶操作符的优先级，则将操作符栈的操作符不断弹出到后缀表达式中，直到op的优先级高于栈顶操作符的优先级，
4. 重复以上操作，直到中缀表达式扫描完毕，之后若操作符栈中仍有元素，则将它们依次弹出至后缀表达式中


注意：
- 用map建立操作符和优先级的映射
- 如果出现括号，只需要在第3步的a与b之前判断，如果是左括号，则压入操作符栈；如果是右括号，就把操作符栈里的元素不断弹出到后缀表达式直到碰到左括号。
- 用string的erase方法可以直接把表达式中的空格去掉


**步骤2：计算后缀表达式**

从左到右扫描后缀表达式，如果是操作数，就压入栈；如果是操作符，就连续弹出两个操作数（注意：后弹出的是第一个操作数，先弹出的是第二操作数），然后进行操作符的操作，生成的新操作数压入栈中。反复直到后缀表达式扫描完毕，这时栈中只会存在一个数，就是最终的答案。
- 注意除法可能导致浮点数，因此操作数类型要设成浮点型
- 如果题目表明可能出现非法表达式，那需要注意每一步使用的对象是否合法










